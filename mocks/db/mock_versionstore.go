// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"zapfs/pkg/types"

	mock "github.com/stretchr/testify/mock"
)

// NewMockVersionStore creates a new instance of MockVersionStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockVersionStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockVersionStore {
	mock := &MockVersionStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockVersionStore is an autogenerated mock type for the VersionStore type
type MockVersionStore struct {
	mock.Mock
}

type MockVersionStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockVersionStore) EXPECT() *MockVersionStore_Expecter {
	return &MockVersionStore_Expecter{mock: &_m.Mock}
}

// DeleteObjectVersion provides a mock function for the type MockVersionStore
func (_mock *MockVersionStore) DeleteObjectVersion(ctx context.Context, bucket string, key string, versionID string) error {
	ret := _mock.Called(ctx, bucket, key, versionID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjectVersion")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = returnFunc(ctx, bucket, key, versionID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockVersionStore_DeleteObjectVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjectVersion'
type MockVersionStore_DeleteObjectVersion_Call struct {
	*mock.Call
}

// DeleteObjectVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
//   - key string
//   - versionID string
func (_e *MockVersionStore_Expecter) DeleteObjectVersion(ctx interface{}, bucket interface{}, key interface{}, versionID interface{}) *MockVersionStore_DeleteObjectVersion_Call {
	return &MockVersionStore_DeleteObjectVersion_Call{Call: _e.mock.On("DeleteObjectVersion", ctx, bucket, key, versionID)}
}

func (_c *MockVersionStore_DeleteObjectVersion_Call) Run(run func(ctx context.Context, bucket string, key string, versionID string)) *MockVersionStore_DeleteObjectVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockVersionStore_DeleteObjectVersion_Call) Return(err error) *MockVersionStore_DeleteObjectVersion_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockVersionStore_DeleteObjectVersion_Call) RunAndReturn(run func(ctx context.Context, bucket string, key string, versionID string) error) *MockVersionStore_DeleteObjectVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectVersion provides a mock function for the type MockVersionStore
func (_mock *MockVersionStore) GetObjectVersion(ctx context.Context, bucket string, key string, versionID string) (*types.ObjectRef, error) {
	ret := _mock.Called(ctx, bucket, key, versionID)

	if len(ret) == 0 {
		panic("no return value specified for GetObjectVersion")
	}

	var r0 *types.ObjectRef
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (*types.ObjectRef, error)); ok {
		return returnFunc(ctx, bucket, key, versionID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) *types.ObjectRef); ok {
		r0 = returnFunc(ctx, bucket, key, versionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ObjectRef)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, bucket, key, versionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockVersionStore_GetObjectVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectVersion'
type MockVersionStore_GetObjectVersion_Call struct {
	*mock.Call
}

// GetObjectVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
//   - key string
//   - versionID string
func (_e *MockVersionStore_Expecter) GetObjectVersion(ctx interface{}, bucket interface{}, key interface{}, versionID interface{}) *MockVersionStore_GetObjectVersion_Call {
	return &MockVersionStore_GetObjectVersion_Call{Call: _e.mock.On("GetObjectVersion", ctx, bucket, key, versionID)}
}

func (_c *MockVersionStore_GetObjectVersion_Call) Run(run func(ctx context.Context, bucket string, key string, versionID string)) *MockVersionStore_GetObjectVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockVersionStore_GetObjectVersion_Call) Return(objectRef *types.ObjectRef, err error) *MockVersionStore_GetObjectVersion_Call {
	_c.Call.Return(objectRef, err)
	return _c
}

func (_c *MockVersionStore_GetObjectVersion_Call) RunAndReturn(run func(ctx context.Context, bucket string, key string, versionID string) (*types.ObjectRef, error)) *MockVersionStore_GetObjectVersion_Call {
	_c.Call.Return(run)
	return _c
}

// ListObjectVersions provides a mock function for the type MockVersionStore
func (_mock *MockVersionStore) ListObjectVersions(ctx context.Context, bucket string, prefix string, keyMarker string, versionIDMarker string, delimiter string, maxKeys int) ([]*types.ObjectVersion, bool, string, string, error) {
	ret := _mock.Called(ctx, bucket, prefix, keyMarker, versionIDMarker, delimiter, maxKeys)

	if len(ret) == 0 {
		panic("no return value specified for ListObjectVersions")
	}

	var r0 []*types.ObjectVersion
	var r1 bool
	var r2 string
	var r3 string
	var r4 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, int) ([]*types.ObjectVersion, bool, string, string, error)); ok {
		return returnFunc(ctx, bucket, prefix, keyMarker, versionIDMarker, delimiter, maxKeys)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, int) []*types.ObjectVersion); ok {
		r0 = returnFunc(ctx, bucket, prefix, keyMarker, versionIDMarker, delimiter, maxKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.ObjectVersion)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, int) bool); ok {
		r1 = returnFunc(ctx, bucket, prefix, keyMarker, versionIDMarker, delimiter, maxKeys)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, string, string, string, int) string); ok {
		r2 = returnFunc(ctx, bucket, prefix, keyMarker, versionIDMarker, delimiter, maxKeys)
	} else {
		r2 = ret.Get(2).(string)
	}
	if returnFunc, ok := ret.Get(3).(func(context.Context, string, string, string, string, string, int) string); ok {
		r3 = returnFunc(ctx, bucket, prefix, keyMarker, versionIDMarker, delimiter, maxKeys)
	} else {
		r3 = ret.Get(3).(string)
	}
	if returnFunc, ok := ret.Get(4).(func(context.Context, string, string, string, string, string, int) error); ok {
		r4 = returnFunc(ctx, bucket, prefix, keyMarker, versionIDMarker, delimiter, maxKeys)
	} else {
		r4 = ret.Error(4)
	}
	return r0, r1, r2, r3, r4
}

// MockVersionStore_ListObjectVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjectVersions'
type MockVersionStore_ListObjectVersions_Call struct {
	*mock.Call
}

// ListObjectVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
//   - prefix string
//   - keyMarker string
//   - versionIDMarker string
//   - delimiter string
//   - maxKeys int
func (_e *MockVersionStore_Expecter) ListObjectVersions(ctx interface{}, bucket interface{}, prefix interface{}, keyMarker interface{}, versionIDMarker interface{}, delimiter interface{}, maxKeys interface{}) *MockVersionStore_ListObjectVersions_Call {
	return &MockVersionStore_ListObjectVersions_Call{Call: _e.mock.On("ListObjectVersions", ctx, bucket, prefix, keyMarker, versionIDMarker, delimiter, maxKeys)}
}

func (_c *MockVersionStore_ListObjectVersions_Call) Run(run func(ctx context.Context, bucket string, prefix string, keyMarker string, versionIDMarker string, delimiter string, maxKeys int)) *MockVersionStore_ListObjectVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 string
		if args[5] != nil {
			arg5 = args[5].(string)
		}
		var arg6 int
		if args[6] != nil {
			arg6 = args[6].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
		)
	})
	return _c
}

func (_c *MockVersionStore_ListObjectVersions_Call) Return(objectVersions []*types.ObjectVersion, b bool, s string, s1 string, err error) *MockVersionStore_ListObjectVersions_Call {
	_c.Call.Return(objectVersions, b, s, s1, err)
	return _c
}

func (_c *MockVersionStore_ListObjectVersions_Call) RunAndReturn(run func(ctx context.Context, bucket string, prefix string, keyMarker string, versionIDMarker string, delimiter string, maxKeys int) ([]*types.ObjectVersion, bool, string, string, error)) *MockVersionStore_ListObjectVersions_Call {
	_c.Call.Return(run)
	return _c
}

// PutDeleteMarker provides a mock function for the type MockVersionStore
func (_mock *MockVersionStore) PutDeleteMarker(ctx context.Context, bucket string, key string, ownerID string) (string, error) {
	ret := _mock.Called(ctx, bucket, key, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for PutDeleteMarker")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (string, error)); ok {
		return returnFunc(ctx, bucket, key, ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) string); ok {
		r0 = returnFunc(ctx, bucket, key, ownerID)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, bucket, key, ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockVersionStore_PutDeleteMarker_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutDeleteMarker'
type MockVersionStore_PutDeleteMarker_Call struct {
	*mock.Call
}

// PutDeleteMarker is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
//   - key string
//   - ownerID string
func (_e *MockVersionStore_Expecter) PutDeleteMarker(ctx interface{}, bucket interface{}, key interface{}, ownerID interface{}) *MockVersionStore_PutDeleteMarker_Call {
	return &MockVersionStore_PutDeleteMarker_Call{Call: _e.mock.On("PutDeleteMarker", ctx, bucket, key, ownerID)}
}

func (_c *MockVersionStore_PutDeleteMarker_Call) Run(run func(ctx context.Context, bucket string, key string, ownerID string)) *MockVersionStore_PutDeleteMarker_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockVersionStore_PutDeleteMarker_Call) Return(versionID string, err error) *MockVersionStore_PutDeleteMarker_Call {
	_c.Call.Return(versionID, err)
	return _c
}

func (_c *MockVersionStore_PutDeleteMarker_Call) RunAndReturn(run func(ctx context.Context, bucket string, key string, ownerID string) (string, error)) *MockVersionStore_PutDeleteMarker_Call {
	_c.Call.Return(run)
	return _c
}
