// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"github.com/LeeDigitalWorks/zapfs/pkg/usage"
	mock "github.com/stretchr/testify/mock"
)

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// AggregateEvents provides a mock function for the type MockStore
func (_mock *MockStore) AggregateEvents(ctx context.Context, ownerID string, bucket string, start time.Time, end time.Time) (*usage.AggregatedSummary, error) {
	ret := _mock.Called(ctx, ownerID, bucket, start, end)

	if len(ret) == 0 {
		panic("no return value specified for AggregateEvents")
	}

	var r0 *usage.AggregatedSummary
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Time, time.Time) (*usage.AggregatedSummary, error)); ok {
		return returnFunc(ctx, ownerID, bucket, start, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Time, time.Time) *usage.AggregatedSummary); ok {
		r0 = returnFunc(ctx, ownerID, bucket, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*usage.AggregatedSummary)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, time.Time, time.Time) error); ok {
		r1 = returnFunc(ctx, ownerID, bucket, start, end)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_AggregateEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AggregateEvents'
type MockStore_AggregateEvents_Call struct {
	*mock.Call
}

// AggregateEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - ownerID string
//   - bucket string
//   - start time.Time
//   - end time.Time
func (_e *MockStore_Expecter) AggregateEvents(ctx interface{}, ownerID interface{}, bucket interface{}, start interface{}, end interface{}) *MockStore_AggregateEvents_Call {
	return &MockStore_AggregateEvents_Call{Call: _e.mock.On("AggregateEvents", ctx, ownerID, bucket, start, end)}
}

func (_c *MockStore_AggregateEvents_Call) Run(run func(ctx context.Context, ownerID string, bucket string, start time.Time, end time.Time)) *MockStore_AggregateEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		var arg4 time.Time
		if args[4] != nil {
			arg4 = args[4].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_AggregateEvents_Call) Return(aggregatedSummary *usage.AggregatedSummary, err error) *MockStore_AggregateEvents_Call {
	_c.Call.Return(aggregatedSummary, err)
	return _c
}

func (_c *MockStore_AggregateEvents_Call) RunAndReturn(run func(ctx context.Context, ownerID string, bucket string, start time.Time, end time.Time) (*usage.AggregatedSummary, error)) *MockStore_AggregateEvents_Call {
	_c.Call.Return(run)
	return _c
}

// ClaimPendingJob provides a mock function for the type MockStore
func (_mock *MockStore) ClaimPendingJob(ctx context.Context) (*usage.ReportJob, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClaimPendingJob")
	}

	var r0 *usage.ReportJob
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*usage.ReportJob, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *usage.ReportJob); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*usage.ReportJob)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ClaimPendingJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClaimPendingJob'
type MockStore_ClaimPendingJob_Call struct {
	*mock.Call
}

// ClaimPendingJob is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) ClaimPendingJob(ctx interface{}) *MockStore_ClaimPendingJob_Call {
	return &MockStore_ClaimPendingJob_Call{Call: _e.mock.On("ClaimPendingJob", ctx)}
}

func (_c *MockStore_ClaimPendingJob_Call) Run(run func(ctx context.Context)) *MockStore_ClaimPendingJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_ClaimPendingJob_Call) Return(reportJob *usage.ReportJob, err error) *MockStore_ClaimPendingJob_Call {
	_c.Call.Return(reportJob, err)
	return _c
}

func (_c *MockStore_ClaimPendingJob_Call) RunAndReturn(run func(ctx context.Context) (*usage.ReportJob, error)) *MockStore_ClaimPendingJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreateReportJob provides a mock function for the type MockStore
func (_mock *MockStore) CreateReportJob(ctx context.Context, job *usage.ReportJob) error {
	ret := _mock.Called(ctx, job)

	if len(ret) == 0 {
		panic("no return value specified for CreateReportJob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *usage.ReportJob) error); ok {
		r0 = returnFunc(ctx, job)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_CreateReportJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateReportJob'
type MockStore_CreateReportJob_Call struct {
	*mock.Call
}

// CreateReportJob is a helper method to define mock.On call
//   - ctx context.Context
//   - job *usage.ReportJob
func (_e *MockStore_Expecter) CreateReportJob(ctx interface{}, job interface{}) *MockStore_CreateReportJob_Call {
	return &MockStore_CreateReportJob_Call{Call: _e.mock.On("CreateReportJob", ctx, job)}
}

func (_c *MockStore_CreateReportJob_Call) Run(run func(ctx context.Context, job *usage.ReportJob)) *MockStore_CreateReportJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *usage.ReportJob
		if args[1] != nil {
			arg1 = args[1].(*usage.ReportJob)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_CreateReportJob_Call) Return(err error) *MockStore_CreateReportJob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_CreateReportJob_Call) RunAndReturn(run func(ctx context.Context, job *usage.ReportJob) error) *MockStore_CreateReportJob_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEventsOlderThan provides a mock function for the type MockStore
func (_mock *MockStore) DeleteEventsOlderThan(ctx context.Context, cutoff time.Time) (int64, error) {
	ret := _mock.Called(ctx, cutoff)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEventsOlderThan")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time) (int64, error)); ok {
		return returnFunc(ctx, cutoff)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time) int64); ok {
		r0 = returnFunc(ctx, cutoff)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Time) error); ok {
		r1 = returnFunc(ctx, cutoff)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DeleteEventsOlderThan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEventsOlderThan'
type MockStore_DeleteEventsOlderThan_Call struct {
	*mock.Call
}

// DeleteEventsOlderThan is a helper method to define mock.On call
//   - ctx context.Context
//   - cutoff time.Time
func (_e *MockStore_Expecter) DeleteEventsOlderThan(ctx interface{}, cutoff interface{}) *MockStore_DeleteEventsOlderThan_Call {
	return &MockStore_DeleteEventsOlderThan_Call{Call: _e.mock.On("DeleteEventsOlderThan", ctx, cutoff)}
}

func (_c *MockStore_DeleteEventsOlderThan_Call) Run(run func(ctx context.Context, cutoff time.Time)) *MockStore_DeleteEventsOlderThan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_DeleteEventsOlderThan_Call) Return(n int64, err error) *MockStore_DeleteEventsOlderThan_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_DeleteEventsOlderThan_Call) RunAndReturn(run func(ctx context.Context, cutoff time.Time) (int64, error)) *MockStore_DeleteEventsOlderThan_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteExpiredReportJobs provides a mock function for the type MockStore
func (_mock *MockStore) DeleteExpiredReportJobs(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExpiredReportJobs")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_DeleteExpiredReportJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteExpiredReportJobs'
type MockStore_DeleteExpiredReportJobs_Call struct {
	*mock.Call
}

// DeleteExpiredReportJobs is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) DeleteExpiredReportJobs(ctx interface{}) *MockStore_DeleteExpiredReportJobs_Call {
	return &MockStore_DeleteExpiredReportJobs_Call{Call: _e.mock.On("DeleteExpiredReportJobs", ctx)}
}

func (_c *MockStore_DeleteExpiredReportJobs_Call) Run(run func(ctx context.Context)) *MockStore_DeleteExpiredReportJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockStore_DeleteExpiredReportJobs_Call) Return(n int64, err error) *MockStore_DeleteExpiredReportJobs_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_DeleteExpiredReportJobs_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockStore_DeleteExpiredReportJobs_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrentStorageByOwner provides a mock function for the type MockStore
func (_mock *MockStore) GetCurrentStorageByOwner(ctx context.Context, ownerID string) ([]usage.BucketSnapshot, error) {
	ret := _mock.Called(ctx, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrentStorageByOwner")
	}

	var r0 []usage.BucketSnapshot
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]usage.BucketSnapshot, error)); ok {
		return returnFunc(ctx, ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []usage.BucketSnapshot); ok {
		r0 = returnFunc(ctx, ownerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]usage.BucketSnapshot)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetCurrentStorageByOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrentStorageByOwner'
type MockStore_GetCurrentStorageByOwner_Call struct {
	*mock.Call
}

// GetCurrentStorageByOwner is a helper method to define mock.On call
//   - ctx context.Context
//   - ownerID string
func (_e *MockStore_Expecter) GetCurrentStorageByOwner(ctx interface{}, ownerID interface{}) *MockStore_GetCurrentStorageByOwner_Call {
	return &MockStore_GetCurrentStorageByOwner_Call{Call: _e.mock.On("GetCurrentStorageByOwner", ctx, ownerID)}
}

func (_c *MockStore_GetCurrentStorageByOwner_Call) Run(run func(ctx context.Context, ownerID string)) *MockStore_GetCurrentStorageByOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetCurrentStorageByOwner_Call) Return(bucketSnapshots []usage.BucketSnapshot, err error) *MockStore_GetCurrentStorageByOwner_Call {
	_c.Call.Return(bucketSnapshots, err)
	return _c
}

func (_c *MockStore_GetCurrentStorageByOwner_Call) RunAndReturn(run func(ctx context.Context, ownerID string) ([]usage.BucketSnapshot, error)) *MockStore_GetCurrentStorageByOwner_Call {
	_c.Call.Return(run)
	return _c
}

// GetDailyUsage provides a mock function for the type MockStore
func (_mock *MockStore) GetDailyUsage(ctx context.Context, ownerID string, start time.Time, end time.Time) ([]usage.DailyUsage, error) {
	ret := _mock.Called(ctx, ownerID, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetDailyUsage")
	}

	var r0 []usage.DailyUsage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time, time.Time) ([]usage.DailyUsage, error)); ok {
		return returnFunc(ctx, ownerID, start, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time, time.Time) []usage.DailyUsage); ok {
		r0 = returnFunc(ctx, ownerID, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]usage.DailyUsage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, time.Time, time.Time) error); ok {
		r1 = returnFunc(ctx, ownerID, start, end)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetDailyUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDailyUsage'
type MockStore_GetDailyUsage_Call struct {
	*mock.Call
}

// GetDailyUsage is a helper method to define mock.On call
//   - ctx context.Context
//   - ownerID string
//   - start time.Time
//   - end time.Time
func (_e *MockStore_Expecter) GetDailyUsage(ctx interface{}, ownerID interface{}, start interface{}, end interface{}) *MockStore_GetDailyUsage_Call {
	return &MockStore_GetDailyUsage_Call{Call: _e.mock.On("GetDailyUsage", ctx, ownerID, start, end)}
}

func (_c *MockStore_GetDailyUsage_Call) Run(run func(ctx context.Context, ownerID string, start time.Time, end time.Time)) *MockStore_GetDailyUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStore_GetDailyUsage_Call) Return(dailyUsages []usage.DailyUsage, err error) *MockStore_GetDailyUsage_Call {
	_c.Call.Return(dailyUsages, err)
	return _c
}

func (_c *MockStore_GetDailyUsage_Call) RunAndReturn(run func(ctx context.Context, ownerID string, start time.Time, end time.Time) ([]usage.DailyUsage, error)) *MockStore_GetDailyUsage_Call {
	_c.Call.Return(run)
	return _c
}

// GetDailyUsageByBucket provides a mock function for the type MockStore
func (_mock *MockStore) GetDailyUsageByBucket(ctx context.Context, ownerID string, bucket string, start time.Time, end time.Time) ([]usage.DailyUsage, error) {
	ret := _mock.Called(ctx, ownerID, bucket, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetDailyUsageByBucket")
	}

	var r0 []usage.DailyUsage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Time, time.Time) ([]usage.DailyUsage, error)); ok {
		return returnFunc(ctx, ownerID, bucket, start, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, time.Time, time.Time) []usage.DailyUsage); ok {
		r0 = returnFunc(ctx, ownerID, bucket, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]usage.DailyUsage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, time.Time, time.Time) error); ok {
		r1 = returnFunc(ctx, ownerID, bucket, start, end)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetDailyUsageByBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDailyUsageByBucket'
type MockStore_GetDailyUsageByBucket_Call struct {
	*mock.Call
}

// GetDailyUsageByBucket is a helper method to define mock.On call
//   - ctx context.Context
//   - ownerID string
//   - bucket string
//   - start time.Time
//   - end time.Time
func (_e *MockStore_Expecter) GetDailyUsageByBucket(ctx interface{}, ownerID interface{}, bucket interface{}, start interface{}, end interface{}) *MockStore_GetDailyUsageByBucket_Call {
	return &MockStore_GetDailyUsageByBucket_Call{Call: _e.mock.On("GetDailyUsageByBucket", ctx, ownerID, bucket, start, end)}
}

func (_c *MockStore_GetDailyUsageByBucket_Call) Run(run func(ctx context.Context, ownerID string, bucket string, start time.Time, end time.Time)) *MockStore_GetDailyUsageByBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		var arg4 time.Time
		if args[4] != nil {
			arg4 = args[4].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockStore_GetDailyUsageByBucket_Call) Return(dailyUsages []usage.DailyUsage, err error) *MockStore_GetDailyUsageByBucket_Call {
	_c.Call.Return(dailyUsages, err)
	return _c
}

func (_c *MockStore_GetDailyUsageByBucket_Call) RunAndReturn(run func(ctx context.Context, ownerID string, bucket string, start time.Time, end time.Time) ([]usage.DailyUsage, error)) *MockStore_GetDailyUsageByBucket_Call {
	_c.Call.Return(run)
	return _c
}

// GetDistinctOwnerBuckets provides a mock function for the type MockStore
func (_mock *MockStore) GetDistinctOwnerBuckets(ctx context.Context, start time.Time, end time.Time) ([]usage.OwnerBucketPair, error) {
	ret := _mock.Called(ctx, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetDistinctOwnerBuckets")
	}

	var r0 []usage.OwnerBucketPair
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, time.Time) ([]usage.OwnerBucketPair, error)); ok {
		return returnFunc(ctx, start, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, time.Time) []usage.OwnerBucketPair); ok {
		r0 = returnFunc(ctx, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]usage.OwnerBucketPair)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Time, time.Time) error); ok {
		r1 = returnFunc(ctx, start, end)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetDistinctOwnerBuckets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDistinctOwnerBuckets'
type MockStore_GetDistinctOwnerBuckets_Call struct {
	*mock.Call
}

// GetDistinctOwnerBuckets is a helper method to define mock.On call
//   - ctx context.Context
//   - start time.Time
//   - end time.Time
func (_e *MockStore_Expecter) GetDistinctOwnerBuckets(ctx interface{}, start interface{}, end interface{}) *MockStore_GetDistinctOwnerBuckets_Call {
	return &MockStore_GetDistinctOwnerBuckets_Call{Call: _e.mock.On("GetDistinctOwnerBuckets", ctx, start, end)}
}

func (_c *MockStore_GetDistinctOwnerBuckets_Call) Run(run func(ctx context.Context, start time.Time, end time.Time)) *MockStore_GetDistinctOwnerBuckets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_GetDistinctOwnerBuckets_Call) Return(ownerBucketPairs []usage.OwnerBucketPair, err error) *MockStore_GetDistinctOwnerBuckets_Call {
	_c.Call.Return(ownerBucketPairs, err)
	return _c
}

func (_c *MockStore_GetDistinctOwnerBuckets_Call) RunAndReturn(run func(ctx context.Context, start time.Time, end time.Time) ([]usage.OwnerBucketPair, error)) *MockStore_GetDistinctOwnerBuckets_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestDailyUsage provides a mock function for the type MockStore
func (_mock *MockStore) GetLatestDailyUsage(ctx context.Context, ownerID string) ([]usage.DailyUsage, error) {
	ret := _mock.Called(ctx, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestDailyUsage")
	}

	var r0 []usage.DailyUsage
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]usage.DailyUsage, error)); ok {
		return returnFunc(ctx, ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []usage.DailyUsage); ok {
		r0 = returnFunc(ctx, ownerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]usage.DailyUsage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetLatestDailyUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestDailyUsage'
type MockStore_GetLatestDailyUsage_Call struct {
	*mock.Call
}

// GetLatestDailyUsage is a helper method to define mock.On call
//   - ctx context.Context
//   - ownerID string
func (_e *MockStore_Expecter) GetLatestDailyUsage(ctx interface{}, ownerID interface{}) *MockStore_GetLatestDailyUsage_Call {
	return &MockStore_GetLatestDailyUsage_Call{Call: _e.mock.On("GetLatestDailyUsage", ctx, ownerID)}
}

func (_c *MockStore_GetLatestDailyUsage_Call) Run(run func(ctx context.Context, ownerID string)) *MockStore_GetLatestDailyUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetLatestDailyUsage_Call) Return(dailyUsages []usage.DailyUsage, err error) *MockStore_GetLatestDailyUsage_Call {
	_c.Call.Return(dailyUsages, err)
	return _c
}

func (_c *MockStore_GetLatestDailyUsage_Call) RunAndReturn(run func(ctx context.Context, ownerID string) ([]usage.DailyUsage, error)) *MockStore_GetLatestDailyUsage_Call {
	_c.Call.Return(run)
	return _c
}

// GetMTDBandwidthEgress provides a mock function for the type MockStore
func (_mock *MockStore) GetMTDBandwidthEgress(ctx context.Context, ownerID string) (int64, error) {
	ret := _mock.Called(ctx, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for GetMTDBandwidthEgress")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return returnFunc(ctx, ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = returnFunc(ctx, ownerID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetMTDBandwidthEgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMTDBandwidthEgress'
type MockStore_GetMTDBandwidthEgress_Call struct {
	*mock.Call
}

// GetMTDBandwidthEgress is a helper method to define mock.On call
//   - ctx context.Context
//   - ownerID string
func (_e *MockStore_Expecter) GetMTDBandwidthEgress(ctx interface{}, ownerID interface{}) *MockStore_GetMTDBandwidthEgress_Call {
	return &MockStore_GetMTDBandwidthEgress_Call{Call: _e.mock.On("GetMTDBandwidthEgress", ctx, ownerID)}
}

func (_c *MockStore_GetMTDBandwidthEgress_Call) Run(run func(ctx context.Context, ownerID string)) *MockStore_GetMTDBandwidthEgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetMTDBandwidthEgress_Call) Return(n int64, err error) *MockStore_GetMTDBandwidthEgress_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_GetMTDBandwidthEgress_Call) RunAndReturn(run func(ctx context.Context, ownerID string) (int64, error)) *MockStore_GetMTDBandwidthEgress_Call {
	_c.Call.Return(run)
	return _c
}

// GetMTDRequestCount provides a mock function for the type MockStore
func (_mock *MockStore) GetMTDRequestCount(ctx context.Context, ownerID string) (int64, error) {
	ret := _mock.Called(ctx, ownerID)

	if len(ret) == 0 {
		panic("no return value specified for GetMTDRequestCount")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return returnFunc(ctx, ownerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = returnFunc(ctx, ownerID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, ownerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetMTDRequestCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMTDRequestCount'
type MockStore_GetMTDRequestCount_Call struct {
	*mock.Call
}

// GetMTDRequestCount is a helper method to define mock.On call
//   - ctx context.Context
//   - ownerID string
func (_e *MockStore_Expecter) GetMTDRequestCount(ctx interface{}, ownerID interface{}) *MockStore_GetMTDRequestCount_Call {
	return &MockStore_GetMTDRequestCount_Call{Call: _e.mock.On("GetMTDRequestCount", ctx, ownerID)}
}

func (_c *MockStore_GetMTDRequestCount_Call) Run(run func(ctx context.Context, ownerID string)) *MockStore_GetMTDRequestCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetMTDRequestCount_Call) Return(n int64, err error) *MockStore_GetMTDRequestCount_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStore_GetMTDRequestCount_Call) RunAndReturn(run func(ctx context.Context, ownerID string) (int64, error)) *MockStore_GetMTDRequestCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetReportJob provides a mock function for the type MockStore
func (_mock *MockStore) GetReportJob(ctx context.Context, jobID string) (*usage.ReportJob, error) {
	ret := _mock.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetReportJob")
	}

	var r0 *usage.ReportJob
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*usage.ReportJob, error)); ok {
		return returnFunc(ctx, jobID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *usage.ReportJob); ok {
		r0 = returnFunc(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*usage.ReportJob)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_GetReportJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReportJob'
type MockStore_GetReportJob_Call struct {
	*mock.Call
}

// GetReportJob is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID string
func (_e *MockStore_Expecter) GetReportJob(ctx interface{}, jobID interface{}) *MockStore_GetReportJob_Call {
	return &MockStore_GetReportJob_Call{Call: _e.mock.On("GetReportJob", ctx, jobID)}
}

func (_c *MockStore_GetReportJob_Call) Run(run func(ctx context.Context, jobID string)) *MockStore_GetReportJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_GetReportJob_Call) Return(reportJob *usage.ReportJob, err error) *MockStore_GetReportJob_Call {
	_c.Call.Return(reportJob, err)
	return _c
}

func (_c *MockStore_GetReportJob_Call) RunAndReturn(run func(ctx context.Context, jobID string) (*usage.ReportJob, error)) *MockStore_GetReportJob_Call {
	_c.Call.Return(run)
	return _c
}

// InsertEvents provides a mock function for the type MockStore
func (_mock *MockStore) InsertEvents(ctx context.Context, events []usage.UsageEvent) error {
	ret := _mock.Called(ctx, events)

	if len(ret) == 0 {
		panic("no return value specified for InsertEvents")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []usage.UsageEvent) error); ok {
		r0 = returnFunc(ctx, events)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_InsertEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertEvents'
type MockStore_InsertEvents_Call struct {
	*mock.Call
}

// InsertEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - events []usage.UsageEvent
func (_e *MockStore_Expecter) InsertEvents(ctx interface{}, events interface{}) *MockStore_InsertEvents_Call {
	return &MockStore_InsertEvents_Call{Call: _e.mock.On("InsertEvents", ctx, events)}
}

func (_c *MockStore_InsertEvents_Call) Run(run func(ctx context.Context, events []usage.UsageEvent)) *MockStore_InsertEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []usage.UsageEvent
		if args[1] != nil {
			arg1 = args[1].([]usage.UsageEvent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_InsertEvents_Call) Return(err error) *MockStore_InsertEvents_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_InsertEvents_Call) RunAndReturn(run func(ctx context.Context, events []usage.UsageEvent) error) *MockStore_InsertEvents_Call {
	_c.Call.Return(run)
	return _c
}

// ListReportJobs provides a mock function for the type MockStore
func (_mock *MockStore) ListReportJobs(ctx context.Context, ownerID string, limit int) ([]usage.ReportJob, error) {
	ret := _mock.Called(ctx, ownerID, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListReportJobs")
	}

	var r0 []usage.ReportJob
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) ([]usage.ReportJob, error)); ok {
		return returnFunc(ctx, ownerID, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) []usage.ReportJob); ok {
		r0 = returnFunc(ctx, ownerID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]usage.ReportJob)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = returnFunc(ctx, ownerID, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStore_ListReportJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReportJobs'
type MockStore_ListReportJobs_Call struct {
	*mock.Call
}

// ListReportJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - ownerID string
//   - limit int
func (_e *MockStore_Expecter) ListReportJobs(ctx interface{}, ownerID interface{}, limit interface{}) *MockStore_ListReportJobs_Call {
	return &MockStore_ListReportJobs_Call{Call: _e.mock.On("ListReportJobs", ctx, ownerID, limit)}
}

func (_c *MockStore_ListReportJobs_Call) Run(run func(ctx context.Context, ownerID string, limit int)) *MockStore_ListReportJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStore_ListReportJobs_Call) Return(reportJobs []usage.ReportJob, err error) *MockStore_ListReportJobs_Call {
	_c.Call.Return(reportJobs, err)
	return _c
}

func (_c *MockStore_ListReportJobs_Call) RunAndReturn(run func(ctx context.Context, ownerID string, limit int) ([]usage.ReportJob, error)) *MockStore_ListReportJobs_Call {
	_c.Call.Return(run)
	return _c
}

// RunPartitionMaintenance provides a mock function for the type MockStore
func (_mock *MockStore) RunPartitionMaintenance(ctx context.Context, monthsAhead int) error {
	ret := _mock.Called(ctx, monthsAhead)

	if len(ret) == 0 {
		panic("no return value specified for RunPartitionMaintenance")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = returnFunc(ctx, monthsAhead)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_RunPartitionMaintenance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunPartitionMaintenance'
type MockStore_RunPartitionMaintenance_Call struct {
	*mock.Call
}

// RunPartitionMaintenance is a helper method to define mock.On call
//   - ctx context.Context
//   - monthsAhead int
func (_e *MockStore_Expecter) RunPartitionMaintenance(ctx interface{}, monthsAhead interface{}) *MockStore_RunPartitionMaintenance_Call {
	return &MockStore_RunPartitionMaintenance_Call{Call: _e.mock.On("RunPartitionMaintenance", ctx, monthsAhead)}
}

func (_c *MockStore_RunPartitionMaintenance_Call) Run(run func(ctx context.Context, monthsAhead int)) *MockStore_RunPartitionMaintenance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_RunPartitionMaintenance_Call) Return(err error) *MockStore_RunPartitionMaintenance_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_RunPartitionMaintenance_Call) RunAndReturn(run func(ctx context.Context, monthsAhead int) error) *MockStore_RunPartitionMaintenance_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateReportJob provides a mock function for the type MockStore
func (_mock *MockStore) UpdateReportJob(ctx context.Context, job *usage.ReportJob) error {
	ret := _mock.Called(ctx, job)

	if len(ret) == 0 {
		panic("no return value specified for UpdateReportJob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *usage.ReportJob) error); ok {
		r0 = returnFunc(ctx, job)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpdateReportJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateReportJob'
type MockStore_UpdateReportJob_Call struct {
	*mock.Call
}

// UpdateReportJob is a helper method to define mock.On call
//   - ctx context.Context
//   - job *usage.ReportJob
func (_e *MockStore_Expecter) UpdateReportJob(ctx interface{}, job interface{}) *MockStore_UpdateReportJob_Call {
	return &MockStore_UpdateReportJob_Call{Call: _e.mock.On("UpdateReportJob", ctx, job)}
}

func (_c *MockStore_UpdateReportJob_Call) Run(run func(ctx context.Context, job *usage.ReportJob)) *MockStore_UpdateReportJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *usage.ReportJob
		if args[1] != nil {
			arg1 = args[1].(*usage.ReportJob)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_UpdateReportJob_Call) Return(err error) *MockStore_UpdateReportJob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpdateReportJob_Call) RunAndReturn(run func(ctx context.Context, job *usage.ReportJob) error) *MockStore_UpdateReportJob_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertDailyUsage provides a mock function for the type MockStore
func (_mock *MockStore) UpsertDailyUsage(ctx context.Context, usage1 *usage.DailyUsage) error {
	ret := _mock.Called(ctx, usage1)

	if len(ret) == 0 {
		panic("no return value specified for UpsertDailyUsage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *usage.DailyUsage) error); ok {
		r0 = returnFunc(ctx, usage1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStore_UpsertDailyUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertDailyUsage'
type MockStore_UpsertDailyUsage_Call struct {
	*mock.Call
}

// UpsertDailyUsage is a helper method to define mock.On call
//   - ctx context.Context
//   - usage1 *usage.DailyUsage
func (_e *MockStore_Expecter) UpsertDailyUsage(ctx interface{}, usage1 interface{}) *MockStore_UpsertDailyUsage_Call {
	return &MockStore_UpsertDailyUsage_Call{Call: _e.mock.On("UpsertDailyUsage", ctx, usage1)}
}

func (_c *MockStore_UpsertDailyUsage_Call) Run(run func(ctx context.Context, usage1 *usage.DailyUsage)) *MockStore_UpsertDailyUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *usage.DailyUsage
		if args[1] != nil {
			arg1 = args[1].(*usage.DailyUsage)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStore_UpsertDailyUsage_Call) Return(err error) *MockStore_UpsertDailyUsage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStore_UpsertDailyUsage_Call) RunAndReturn(run func(ctx context.Context, usage1 *usage.DailyUsage) error) *MockStore_UpsertDailyUsage_Call {
	_c.Call.Return(run)
	return _c
}
