# ZapFS CI Pipeline
#
# Runs on every push and pull request to main branch.
# Stages:
#   1. Parallel: Unit tests, lint, staticcheck, build
#   2. Build Docker image (depends on stage 1)
#   3. Parallel integration tests using Docker Compose clusters
#
# Integration test groups:
#   - minimal-cluster: S3 API + Resiliency tests (validates E2E + internal state)
#   - full-cluster: Manager failover tests (requires 3-node Raft)

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  GO_VERSION: '1.25.0'
  DOCKER_BUILDKIT: 1

jobs:
  # ===========================================================================
  # Stage 1: Fast checks (parallel)
  # ===========================================================================

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run unit tests with race detector
        run: make test-race

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: coverage.out
          fail_ci_if_error: false

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: latest
          args: --timeout=5m

  staticcheck:
    name: Staticcheck
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install staticcheck
        run: go install honnef.co/go/tools/cmd/staticcheck@latest

      - name: Run staticcheck
        run: staticcheck ./...

  build:
    name: Build Binary
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build enterprise binary
        run: make build

      - name: Verify binary runs
        run: ./zapfs --version

  # ===========================================================================
  # Stage 2: Build Docker image
  # ===========================================================================

  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [unit-tests, lint, staticcheck, build]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and export Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile
          tags: zapfs:ci
          outputs: type=docker,dest=/tmp/zapfs-image.tar
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/zapfs-image.tar
          retention-days: 1

  # ===========================================================================
  # Stage 3: Integration tests (parallel clusters)
  # ===========================================================================

  # Minimal cluster: 1 manager, 2 file servers, 1 metadata
  # Tests against both MySQL and PostgreSQL in parallel using matrix
  # Runs S3 API tests + resiliency tests (with DB state validation)
  integration-minimal:
    name: Integration (Minimal - ${{ matrix.database }})
    runs-on: ubuntu-latest
    needs: docker-build
    strategy:
      fail-fast: false
      matrix:
        database: [mysql, postgres]
        include:
          - database: mysql
            compose_files: "-f docker-compose.minimal.yml"
            db_dsn: "zapfs:zapfs@tcp(localhost:3306)/zapfs"
            db_port: 3306
          - database: postgres
            compose_files: "-f docker-compose.minimal.yml -f docker-compose.minimal.postgres.yml"
            db_dsn: "postgres://zapfs:zapfs@localhost:5432/zapfs?sslmode=disable"
            db_port: 5432
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load --input /tmp/zapfs-image.tar

      - name: Tag image for compose
        run: docker tag zapfs:ci zapfs:minimal

      - name: Start minimal cluster with ${{ matrix.database }}
        run: |
          cd docker
          docker compose ${{ matrix.compose_files }} up -d

          # Wait for services to be healthy
          echo "Waiting for ${{ matrix.database }} cluster..."
          for i in {1..90}; do
            HEALTHY=$(docker compose ${{ matrix.compose_files }} ps 2>/dev/null | grep -c "(healthy)" || echo 0)
            echo "Healthy services: $HEALTHY/5"
            if [ "$HEALTHY" -ge 4 ]; then
              echo "Cluster is ready"
              break
            fi
            sleep 2
          done

          docker compose ${{ matrix.compose_files }} ps

      - name: Run S3 integration tests
        run: make integration-s3
        env:
          S3_ENDPOINT: http://localhost:8082
          FILE_SERVER_1_ADDR: localhost:8081
          FILE_SERVER_2_ADDR: localhost:8091

      - name: Run resiliency tests (with DB validation)
        run: make integration-resiliency
        env:
          DB_DSN: ${{ matrix.db_dsn }}
          S3_ENDPOINT: http://localhost:8082
          FILE_SERVER_1_ADDR: localhost:8081
          FILE_SERVER_2_ADDR: localhost:8091

      - name: Run file server tests
        run: make integration-file
        env:
          FILE_SERVER_1_ADDR: localhost:8081
          FILE_SERVER_2_ADDR: localhost:8091

      - name: Collect logs on failure
        if: failure()
        run: |
          cd docker
          docker compose ${{ matrix.compose_files }} logs > /tmp/cluster-logs.txt

      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: minimal-cluster-logs-${{ matrix.database }}
          path: /tmp/cluster-logs.txt

      - name: Cleanup
        if: always()
        run: |
          cd docker
          docker compose ${{ matrix.compose_files }} down -v || true

  # Full cluster: 3 managers (Raft), 2 file servers, 1 metadata, MySQL
  # Runs manager failover tests (kills/restarts nodes)
  integration-full:
    name: Integration (Full Cluster - Failover)
    runs-on: ubuntu-latest
    needs: docker-build
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load --input /tmp/zapfs-image.tar

      - name: Tag image for compose
        run: docker tag zapfs:ci zapfs:latest

      - name: Start full cluster
        run: |
          cd docker
          docker compose up -d

          # Wait for 3-node Raft cluster to form
          echo "Waiting for Raft cluster..."
          for i in {1..90}; do
            HEALTHY=$(docker compose ps | grep -c "(healthy)" || echo 0)
            echo "Healthy services: $HEALTHY"
            if [ "$HEALTHY" -ge 6 ]; then
              echo "Full cluster is ready"
              break
            fi
            sleep 2
          done

          docker compose ps

      - name: Run manager failover tests
        run: make integration-manager
        env:
          MANAGER_1_ADDR: localhost:8050
          MANAGER_2_ADDR: localhost:8052
          MANAGER_3_ADDR: localhost:8054

      - name: Collect logs on failure
        if: failure()
        run: |
          cd docker
          docker compose logs > /tmp/full-cluster-logs.txt

      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: full-cluster-logs
          path: /tmp/full-cluster-logs.txt

      - name: Cleanup
        if: always()
        run: |
          cd docker
          docker compose down -v

  # Metadata tests with in-memory DB (fast, no Docker needed)
  integration-metadata:
    name: Integration (Metadata - In-Memory)
    runs-on: ubuntu-latest
    needs: [unit-tests, lint]  # Can run earlier, no Docker image needed
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run metadata tests (in-memory DB)
        run: go test -race -v -tags=integration,enterprise -count=1 ./integration/metadata/...
        # Note: No DB_DSN means tests use in-memory database

  # ===========================================================================
  # Final status check (for branch protection)
  # ===========================================================================

  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [integration-minimal, integration-full, integration-metadata]
    if: always()
    steps:
      - name: Check all jobs passed
        run: |
          if [[ "${{ needs.integration-minimal.result }}" != "success" ]]; then
            echo "integration-minimal failed"
            exit 1
          fi
          if [[ "${{ needs.integration-full.result }}" != "success" ]]; then
            echo "integration-full failed"
            exit 1
          fi
          if [[ "${{ needs.integration-metadata.result }}" != "success" ]]; then
            echo "integration-metadata failed"
            exit 1
          fi
          echo "All CI checks passed!"
