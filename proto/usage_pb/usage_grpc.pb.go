// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v6.33.2
// source: usage.proto

package usage_pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UsageReportingService_RequestReport_FullMethodName      = "/usage_pb.UsageReportingService/RequestReport"
	UsageReportingService_GetReport_FullMethodName          = "/usage_pb.UsageReportingService/GetReport"
	UsageReportingService_GetCurrentUsage_FullMethodName    = "/usage_pb.UsageReportingService/GetCurrentUsage"
	UsageReportingService_StreamUsageUpdates_FullMethodName = "/usage_pb.UsageReportingService/StreamUsageUpdates"
	UsageReportingService_ListReports_FullMethodName        = "/usage_pb.UsageReportingService/ListReports"
)

// UsageReportingServiceClient is the client API for UsageReportingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UsageReportingServiceClient interface {
	// RequestReport queues an async usage report generation job.
	RequestReport(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*ReportJob, error)
	// GetReport retrieves the status or result of a report job.
	GetReport(ctx context.Context, in *GetReportRequest, opts ...grpc.CallOption) (*GetReportResponse, error)
	// GetCurrentUsage returns real-time usage estimate without report generation.
	GetCurrentUsage(ctx context.Context, in *CurrentUsageRequest, opts ...grpc.CallOption) (*CurrentUsage, error)
	// StreamUsageUpdates streams real-time usage updates for dashboards.
	StreamUsageUpdates(ctx context.Context, in *StreamUsageRequest, opts ...grpc.CallOption) (UsageReportingService_StreamUsageUpdatesClient, error)
	// ListReports lists recent report jobs for an owner.
	ListReports(ctx context.Context, in *ListReportsRequest, opts ...grpc.CallOption) (*ListReportsResponse, error)
}

type usageReportingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUsageReportingServiceClient(cc grpc.ClientConnInterface) UsageReportingServiceClient {
	return &usageReportingServiceClient{cc}
}

func (c *usageReportingServiceClient) RequestReport(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*ReportJob, error) {
	out := new(ReportJob)
	err := c.cc.Invoke(ctx, UsageReportingService_RequestReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usageReportingServiceClient) GetReport(ctx context.Context, in *GetReportRequest, opts ...grpc.CallOption) (*GetReportResponse, error) {
	out := new(GetReportResponse)
	err := c.cc.Invoke(ctx, UsageReportingService_GetReport_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usageReportingServiceClient) GetCurrentUsage(ctx context.Context, in *CurrentUsageRequest, opts ...grpc.CallOption) (*CurrentUsage, error) {
	out := new(CurrentUsage)
	err := c.cc.Invoke(ctx, UsageReportingService_GetCurrentUsage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usageReportingServiceClient) StreamUsageUpdates(ctx context.Context, in *StreamUsageRequest, opts ...grpc.CallOption) (UsageReportingService_StreamUsageUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &UsageReportingService_ServiceDesc.Streams[0], UsageReportingService_StreamUsageUpdates_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &usageReportingServiceStreamUsageUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UsageReportingService_StreamUsageUpdatesClient interface {
	Recv() (*UsageUpdate, error)
	grpc.ClientStream
}

type usageReportingServiceStreamUsageUpdatesClient struct {
	grpc.ClientStream
}

func (x *usageReportingServiceStreamUsageUpdatesClient) Recv() (*UsageUpdate, error) {
	m := new(UsageUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *usageReportingServiceClient) ListReports(ctx context.Context, in *ListReportsRequest, opts ...grpc.CallOption) (*ListReportsResponse, error) {
	out := new(ListReportsResponse)
	err := c.cc.Invoke(ctx, UsageReportingService_ListReports_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsageReportingServiceServer is the server API for UsageReportingService service.
// All implementations must embed UnimplementedUsageReportingServiceServer
// for forward compatibility
type UsageReportingServiceServer interface {
	// RequestReport queues an async usage report generation job.
	RequestReport(context.Context, *ReportRequest) (*ReportJob, error)
	// GetReport retrieves the status or result of a report job.
	GetReport(context.Context, *GetReportRequest) (*GetReportResponse, error)
	// GetCurrentUsage returns real-time usage estimate without report generation.
	GetCurrentUsage(context.Context, *CurrentUsageRequest) (*CurrentUsage, error)
	// StreamUsageUpdates streams real-time usage updates for dashboards.
	StreamUsageUpdates(*StreamUsageRequest, UsageReportingService_StreamUsageUpdatesServer) error
	// ListReports lists recent report jobs for an owner.
	ListReports(context.Context, *ListReportsRequest) (*ListReportsResponse, error)
	mustEmbedUnimplementedUsageReportingServiceServer()
}

// UnimplementedUsageReportingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUsageReportingServiceServer struct {
}

func (UnimplementedUsageReportingServiceServer) RequestReport(context.Context, *ReportRequest) (*ReportJob, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestReport not implemented")
}
func (UnimplementedUsageReportingServiceServer) GetReport(context.Context, *GetReportRequest) (*GetReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReport not implemented")
}
func (UnimplementedUsageReportingServiceServer) GetCurrentUsage(context.Context, *CurrentUsageRequest) (*CurrentUsage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentUsage not implemented")
}
func (UnimplementedUsageReportingServiceServer) StreamUsageUpdates(*StreamUsageRequest, UsageReportingService_StreamUsageUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUsageUpdates not implemented")
}
func (UnimplementedUsageReportingServiceServer) ListReports(context.Context, *ListReportsRequest) (*ListReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReports not implemented")
}
func (UnimplementedUsageReportingServiceServer) mustEmbedUnimplementedUsageReportingServiceServer() {}

// UnsafeUsageReportingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UsageReportingServiceServer will
// result in compilation errors.
type UnsafeUsageReportingServiceServer interface {
	mustEmbedUnimplementedUsageReportingServiceServer()
}

func RegisterUsageReportingServiceServer(s grpc.ServiceRegistrar, srv UsageReportingServiceServer) {
	s.RegisterService(&UsageReportingService_ServiceDesc, srv)
}

func _UsageReportingService_RequestReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageReportingServiceServer).RequestReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageReportingService_RequestReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageReportingServiceServer).RequestReport(ctx, req.(*ReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsageReportingService_GetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageReportingServiceServer).GetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageReportingService_GetReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageReportingServiceServer).GetReport(ctx, req.(*GetReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsageReportingService_GetCurrentUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrentUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageReportingServiceServer).GetCurrentUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageReportingService_GetCurrentUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageReportingServiceServer).GetCurrentUsage(ctx, req.(*CurrentUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsageReportingService_StreamUsageUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamUsageRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsageReportingServiceServer).StreamUsageUpdates(m, &usageReportingServiceStreamUsageUpdatesServer{stream})
}

type UsageReportingService_StreamUsageUpdatesServer interface {
	Send(*UsageUpdate) error
	grpc.ServerStream
}

type usageReportingServiceStreamUsageUpdatesServer struct {
	grpc.ServerStream
}

func (x *usageReportingServiceStreamUsageUpdatesServer) Send(m *UsageUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _UsageReportingService_ListReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageReportingServiceServer).ListReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageReportingService_ListReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageReportingServiceServer).ListReports(ctx, req.(*ListReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UsageReportingService_ServiceDesc is the grpc.ServiceDesc for UsageReportingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UsageReportingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "usage_pb.UsageReportingService",
	HandlerType: (*UsageReportingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestReport",
			Handler:    _UsageReportingService_RequestReport_Handler,
		},
		{
			MethodName: "GetReport",
			Handler:    _UsageReportingService_GetReport_Handler,
		},
		{
			MethodName: "GetCurrentUsage",
			Handler:    _UsageReportingService_GetCurrentUsage_Handler,
		},
		{
			MethodName: "ListReports",
			Handler:    _UsageReportingService_ListReports_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamUsageUpdates",
			Handler:       _UsageReportingService_StreamUsageUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "usage.proto",
}
