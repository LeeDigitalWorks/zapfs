syntax = "proto3";

package manager_pb;
option go_package = "github.com/LeeDigitalWorks/zapfs/proto/manager_pb";

import "common.proto";
import "google/protobuf/timestamp.proto";

service ManagerService {
  rpc RegisterService (RegisterServiceRequest) returns (RegisterServiceResponse);
  rpc UnregisterService (UnregisterServiceRequest) returns (UnregisterServiceResponse);
  rpc Heartbeat (HeartbeatRequest) returns (HeartbeatResponse);

  rpc CreateCollection(CreateCollectionRequest) returns (CreateCollectionResponse);
  rpc ListCollections(ListCollectionsRequest) returns (stream Collection);
  rpc GetCollection(GetCollectionRequest) returns (GetCollectionResponse);
  rpc DeleteCollection(DeleteCollectionRequest) returns (DeleteCollectionResponse);

  rpc RaftListClusterServers (RaftListClusterServersRequest) returns (RaftListClusterServersResponse);
  rpc RaftAddServer (RaftAddServerRequest) returns (RaftAddServerResponse);
  rpc RaftRemoveServer (RaftRemoveServerRequest) returns (RaftRemoveServerResponse);
  rpc Ping (PingRequest) returns (PingResponse);

  rpc GetReplicationTargets(GetReplicationTargetsRequest) returns (GetReplicationTargetsResponse);

  rpc WatchTopology(WatchTopologyRequest) returns (stream TopologyEvent);

  // WatchCollections streams collection changes for multi-region cache sync.
  // Sends initial sync of collections since the requested time, then pushes updates.
  rpc WatchCollections(WatchCollectionsRequest) returns (stream CollectionEvent);

  // Reconciliation - File server calls this to get expected chunks.
  // Manager queries metadata service and streams chunk IDs.
  rpc GetExpectedChunks(GetExpectedChunksRequest) returns (stream ExpectedChunkResponse);

  // ReportReconciliation - File server reports reconciliation results.
  rpc ReportReconciliation(ReconciliationReport) returns (ReconciliationAck);

  // TriggerReconciliation - Admin API to manually trigger reconciliation for a server.
  rpc TriggerReconciliation(TriggerReconciliationRequest) returns (TriggerReconciliationResponse);

  // Backup RPCs (enterprise - requires FeatureBackup license)
  rpc CreateBackup(CreateBackupRequest) returns (CreateBackupResponse);
  rpc GetBackupStatus(GetBackupStatusRequest) returns (GetBackupStatusResponse);
  rpc ListBackups(ListBackupsRequest) returns (ListBackupsResponse);
  rpc DeleteBackup(DeleteBackupRequest) returns (DeleteBackupResponse);

  // Cluster rebalancing RPCs
  rpc GetClusterStatus(GetClusterStatusRequest) returns (GetClusterStatusResponse);
  rpc CalculateRebalancePlan(CalculateRebalancePlanRequest) returns (CalculateRebalancePlanResponse);
  rpc ExecuteRebalance(ExecuteRebalanceRequest) returns (stream RebalanceProgress);

  // RecoverCollections rebuilds collection state from metadata service databases.
  // Used for disaster recovery when Raft data is lost but metadata DBs are intact.
  // Must be called on the leader node.
  rpc RecoverCollections(RecoverCollectionsRequest) returns (RecoverCollectionsResponse);
}

enum ServiceType {
  FILE_SERVICE = 0;
  METADATA_SERVICE = 1;
}

message ServiceInfo {
  ServiceType service_type = 1;
  common_pb.Location location = 2;
  google.protobuf.Timestamp last_heartbeat = 3;
}

message StorageBackend {
  string type = 1;
  string id = 2;
  map<string, string> properties = 3;
  repeated common_pb.Backend backends = 4;
}

message PlacementPolicy {
  string algorithm = 1;
  uint32 num_replicas = 2;
  map<string, TierPolicy> tier_policies = 3;
}

message TierPolicy {
  string tier = 1;
  repeated string disk_types = 2;
  int32 replica_count = 3;
}

message FileServiceMetadata {
  repeated StorageBackend storage_backends = 1;
}

message MetadataServiceMetadata {
  // Number of buckets in this metadata service's local database.
  // Used by manager to detect data loss (manager has 0 collections but metadata has buckets).
  uint64 bucket_count = 1;
}

message RegisterServiceRequest {
  ServiceType service_type = 1;
  common_pb.Location location = 2;

  oneof service_metadata {
    FileServiceMetadata file_service = 10;
    MetadataServiceMetadata metadata_service = 11;
  }
}

message RegisterServiceResponse {
  bool success = 1;
  string message = 2;
  uint64 version = 3;
  PlacementPolicy placement_policy = 4;
  repeated ServiceInfo peer_services = 5;
}

message UnregisterServiceRequest {
  ServiceType service_type = 1;
  common_pb.Location location = 2;
}

message UnregisterServiceResponse {
  bool success = 1;
  string message = 2;
}

message HeartbeatRequest {
  ServiceType service_type = 1;
  common_pb.Location location = 2;
  uint64 version = 3;

  oneof service_metadata {
    FileServiceMetadata file_service = 10;
    MetadataServiceMetadata metadata_service = 11;
  }
}

message HeartbeatResponse {
  bool topology_changed = 1;
  uint64 topology_version = 2;
  PlacementPolicy placement_policy = 3;
}

message GetReplicationTargetsRequest {
  uint64 file_size = 1;
  uint32 num_replicas = 2;
  string tier = 3;
}

message GetReplicationTargetsResponse {
  repeated ReplicationTarget targets = 1;
}

message ReplicationTarget {
  common_pb.Location location = 1;
  string backend_id = 2;
  string backend_type = 3;
  int32 priority = 4;
}

message WatchTopologyRequest {
  uint64 current_version = 1;  // Client's current version (0 for full sync)
}

message TopologyEvent {
  enum EventType {
    FULL_SYNC = 0;        // Initial full topology on subscribe
    SERVICE_ADDED = 1;    // New service registered
    SERVICE_REMOVED = 2;  // Service unregistered or offline
    SERVICE_UPDATED = 3;  // Service metadata changed (backends, status)
  }

  EventType type = 1;
  uint64 version = 2;              // New topology version
  repeated ServiceInfo services = 3; // Affected services
}

// WatchCollections request for multi-region cache sync
message WatchCollectionsRequest {
  // Resume from this timestamp (zero = full sync)
  google.protobuf.Timestamp since_time = 1;
  // Include tombstoned (deleted) collections in sync
  bool include_tombstoned = 2;
}

// CollectionEvent is pushed to subscribers when collections change
message CollectionEvent {
  enum EventType {
    FULL_SYNC = 0;   // Initial batch of collections on subscribe
    CREATED = 1;     // New collection created
    DELETED = 2;     // Collection deleted (tombstoned)
    UPDATED = 3;     // Collection metadata updated
  }

  EventType type = 1;
  // The collection that changed (or batch for FULL_SYNC)
  repeated Collection collections = 2;
  // Current collections version for consistency tracking
  uint64 version = 3;
  // Timestamp of this event (for resume on reconnect)
  google.protobuf.Timestamp timestamp = 4;
}

message RaftListClusterServersRequest {}

message RaftListClusterServersResponse {
  message Server {
    string id = 1;
    string address = 2;
    bool is_leader = 3;
  }
  repeated Server servers = 1;
}

message RaftAddServerRequest {
  string id = 1;
  string address = 2;
  bool is_voter = 3;
}

message RaftAddServerResponse {
  bool success = 1;
  string message = 2;
}

message RaftRemoveServerRequest {
  string id = 1;
  bool force = 2;
}

message RaftRemoveServerResponse {
  bool success = 1;
  string message = 2;
}

message PingRequest {}

message PingResponse {
  google.protobuf.Timestamp start_time = 1;
  google.protobuf.Timestamp current_time = 2;
  google.protobuf.Timestamp stop_time = 3;
  bool is_leader = 4;
  string version = 5;
}

// Collection management
message Collection {
  string name = 1;
  string owner = 2;
  google.protobuf.Timestamp created_at = 3;
  google.protobuf.Timestamp updated_at = 4;

  // Async Deletion Flag
  bool delete_pending = 5;

  // Current usage
  int64 current_objects = 6;
  int64 current_size_bytes = 7;

  // Metadata
  map<string, string> tags = 8;
  string description = 9;

  string tier = 10;

  // Tombstone Flag to update caches
  bool is_deleted = 11;

  // Federation: Bucket mode for passthrough/migration
  // 0 = LOCAL (default), 1 = PASSTHROUGH, 2 = MIGRATING
  FederationBucketMode bucket_mode = 12;
}

message CreateCollectionRequest {
  string name = 1;
  string owner = 2;
 
  // Metadata
  map<string, string> tags = 7;
  string description = 8;
}

message CreateCollectionResponse {
  bool success = 1;
  string message = 2;
  Collection collection = 3;
}

message ListCollectionsRequest {
  google.protobuf.Timestamp since_time = 2;
  bool include_tombstoned = 3;
}

message GetCollectionRequest {
  string name = 1;
}

message GetCollectionResponse {
  Collection collection = 1;
}

message DeleteCollectionRequest {
  string name = 1;
  string owner = 2; // Optional ownership check
}

message DeleteCollectionResponse {
  bool success = 1;
  string message = 2;
}

// File Server State for reconciliation tracking
enum FileServerState {
  FILE_SERVER_STATE_UNKNOWN = 0;
  FILE_SERVER_STATE_ONLINE = 1;       // Normal operation, can receive writes
  FILE_SERVER_STATE_RECONCILING = 2;  // Syncing chunks, excluded from placement
  FILE_SERVER_STATE_OFFLINE = 3;      // Not responding to heartbeats
}

// Reconciliation messages

message GetExpectedChunksRequest {
  string server_id = 1;  // File server address requesting reconciliation
}

message ExpectedChunkResponse {
  string chunk_id = 1;
}

message ReconciliationReport {
  string server_id = 1;
  int64 total_chunks = 2;           // Total chunks on file server
  int64 expected_chunks = 3;        // Chunks expected (from registry)
  int64 orphans_deleted = 4;        // Orphan chunks deleted
  int64 orphans_skipped = 5;        // Orphan chunks skipped (too new, within grace period)
  repeated string missing_chunks = 6; // Chunks in registry but not on disk
  int64 duration_ms = 7;            // How long reconciliation took
}

message ReconciliationAck {
  bool success = 1;
  string message = 2;
}

message TriggerReconciliationRequest {
  string server_id = 1;  // Empty = all servers
}

message TriggerReconciliationResponse {
  bool success = 1;
  string message = 2;
  repeated string servers_triggered = 3;
}

// Backup messages

message CreateBackupRequest {
  // Optional description for this backup
  string description = 1;
}

message CreateBackupResponse {
  bool success = 1;
  string backup_id = 2;
  bytes snapshot_data = 3;  // JSON-encoded FSM snapshot
  string error = 4;
}

message GetBackupStatusRequest {}

message GetBackupStatusResponse {
  uint64 topology_version = 1;
  uint64 collections_version = 2;
  int32 file_services_count = 3;
  int32 metadata_services_count = 4;
  int32 collections_count = 5;
  bool is_leader = 6;
}

message ListBackupsRequest {}

message ListBackupsResponse {
  repeated BackupInfo backups = 1;
}

message BackupInfo {
  string backup_id = 1;
  int64 created_at = 2;  // Unix timestamp
  uint64 topology_version = 3;
  uint64 collections_version = 4;
  int32 file_services_count = 5;
  int32 metadata_services_count = 6;
  int32 collections_count = 7;
  int64 size_bytes = 8;
  string filename = 9;
  string description = 10;
  bool scheduled = 11;  // true if created by scheduler
}

message DeleteBackupRequest {
  string backup_id = 1;
}

message DeleteBackupResponse {
  bool success = 1;
  string error = 2;
}

// Cluster rebalancing messages

message GetClusterStatusRequest {}

message GetClusterStatusResponse {
  repeated FileServerStatus file_servers = 1;
  ClusterCapacitySummary capacity = 2;
}

message FileServerStatus {
  string server_id = 1;
  string address = 2;
  int64 total_bytes = 3;
  int64 used_bytes = 4;
  int64 chunk_count = 5;
  double usage_percent = 6;
  string status = 7;  // "online", "offline", "draining"
  google.protobuf.Timestamp last_heartbeat = 8;
}

message ClusterCapacitySummary {
  int64 total_bytes = 1;
  int64 used_bytes = 2;
  double avg_usage_percent = 3;
  double max_usage_percent = 4;
  double min_usage_percent = 5;
  double imbalance_percent = 6;  // max - min usage
  int32 online_servers = 7;
}

message CalculateRebalancePlanRequest {
  // Target usage variance (default: 5%)
  // Servers within this % of average won't be touched
  double target_variance_percent = 1;

  // Max bytes to move (0 = unlimited)
  int64 max_bytes_to_move = 2;

  // Dry run - just calculate, don't store plan
  bool dry_run = 3;
}

message CalculateRebalancePlanResponse {
  bool success = 1;
  string error = 2;
  RebalancePlan plan = 3;
}

message RebalancePlan {
  string plan_id = 1;
  repeated ChunkMigration migrations = 2;
  int64 total_bytes = 3;
  int32 total_chunks = 4;
  int64 estimated_duration_ms = 5;  // Based on bandwidth estimate
  google.protobuf.Timestamp created_at = 6;
}

message ChunkMigration {
  string chunk_id = 1;
  string from_server = 2;
  string to_server = 3;
  int64 size_bytes = 4;
  int32 priority = 5;  // Higher = more urgent
}

message ExecuteRebalanceRequest {
  // Plan ID from CalculateRebalancePlan (empty = calculate new plan)
  string plan_id = 1;

  // Rate limit in bytes/second (0 = unlimited)
  int64 rate_limit_bps = 2;

  // Max concurrent migrations per server
  int32 max_concurrent = 3;

  // Delete source chunk after migration
  bool delete_source = 4;
}

message RebalanceProgress {
  string plan_id = 1;
  int32 migrations_completed = 2;
  int32 migrations_total = 3;
  int64 bytes_moved = 4;
  int64 bytes_total = 5;
  double progress_percent = 6;
  string current_chunk = 7;
  string status = 8;  // "running", "completed", "failed", "cancelled"
  string error = 9;
}

// Federation Service for S3 bucket federation and migration control
service FederationService {
  // Register an existing external S3 bucket for federation
  rpc RegisterBucket(FederationRegisterBucketRequest) returns (FederationRegisterBucketResponse);

  // Unregister a federated bucket
  rpc UnregisterBucket(FederationUnregisterBucketRequest) returns (FederationUnregisterBucketResponse);

  // Get federation status for a bucket
  rpc GetBucketStatus(FederationGetBucketStatusRequest) returns (FederationGetBucketStatusResponse);

  // Change bucket mode (passthrough → migrating → local)
  rpc SetBucketMode(FederationSetBucketModeRequest) returns (FederationSetBucketModeResponse);

  // Pause an active migration
  rpc PauseMigration(FederationPauseMigrationRequest) returns (FederationPauseMigrationResponse);

  // Resume a paused migration
  rpc ResumeMigration(FederationResumeMigrationRequest) returns (FederationResumeMigrationResponse);

  // Enable/disable dual-write for a bucket in migrating mode
  rpc SetDualWrite(FederationSetDualWriteRequest) returns (FederationSetDualWriteResponse);

  // Update external S3 credentials (for rotation)
  rpc UpdateCredentials(FederationUpdateCredentialsRequest) returns (FederationUpdateCredentialsResponse);

  // List all federated buckets
  rpc ListFederatedBuckets(FederationListBucketsRequest) returns (FederationListBucketsResponse);
}

// Bucket mode for federation
enum FederationBucketMode {
  FEDERATION_BUCKET_MODE_UNSPECIFIED = 0;
  FEDERATION_BUCKET_MODE_LOCAL = 1;       // Normal ZapFS bucket (no federation)
  FEDERATION_BUCKET_MODE_PASSTHROUGH = 2; // Proxy to external S3, metadata local
  FEDERATION_BUCKET_MODE_MIGRATING = 3;   // Ingesting from external S3 to local
}

// External S3 connection configuration
message ExternalS3Config {
  string endpoint = 1;           // e.g., "s3.amazonaws.com"
  string region = 2;             // e.g., "us-east-1"
  string access_key_id = 3;
  string secret_access_key = 4;
  string bucket = 5;             // Bucket name on external S3
  bool path_style = 6;           // Use path-style addressing
}

// Request to register a bucket for federation
message FederationRegisterBucketRequest {
  string local_bucket = 1;           // Local bucket name (created if not exists)
  FederationBucketMode mode = 2;     // PASSTHROUGH or MIGRATING
  ExternalS3Config external = 3;     // External S3 connection details
  bool start_active_migration = 4;   // If MIGRATING, start workers immediately
}

message FederationRegisterBucketResponse {
  bool success = 1;
  string error = 2;
  int64 external_object_count = 3;   // Objects discovered in external bucket (if migrating)
}

// Request to unregister a federated bucket
message FederationUnregisterBucketRequest {
  string bucket = 1;
  bool delete_external = 2;          // Also delete bucket on external S3
  bool delete_local_data = 3;        // Delete locally ingested data
}

message FederationUnregisterBucketResponse {
  bool success = 1;
  string error = 2;
}

// Request to get federation status
message FederationGetBucketStatusRequest {
  string bucket = 1;
}

message FederationGetBucketStatusResponse {
  string bucket = 1;
  FederationBucketMode mode = 2;
  bool dual_write_enabled = 3;
  bool migration_paused = 4;
  int64 objects_discovered = 5;
  int64 objects_synced = 6;
  int64 bytes_synced = 7;
  double progress_percent = 8;       // objects_synced / objects_discovered * 100
  ExternalS3Config external = 9;     // Credentials redacted in response
  int64 created_at = 10;             // Unix timestamp
  int64 updated_at = 11;             // Unix timestamp
}

// Request to change bucket mode
message FederationSetBucketModeRequest {
  string bucket = 1;
  FederationBucketMode mode = 2;
  bool delete_external_on_complete = 3;  // Delete external data when transitioning to LOCAL
}

message FederationSetBucketModeResponse {
  bool success = 1;
  string error = 2;
}

// Pause migration request
message FederationPauseMigrationRequest {
  string bucket = 1;
}

message FederationPauseMigrationResponse {
  bool success = 1;
  string error = 2;
}

// Resume migration request
message FederationResumeMigrationRequest {
  string bucket = 1;
}

message FederationResumeMigrationResponse {
  bool success = 1;
  string error = 2;
}

// Set dual-write request
message FederationSetDualWriteRequest {
  string bucket = 1;
  bool enabled = 2;
}

message FederationSetDualWriteResponse {
  bool success = 1;
  string error = 2;
}

// Update credentials request
message FederationUpdateCredentialsRequest {
  string bucket = 1;
  string access_key_id = 2;
  string secret_access_key = 3;
}

message FederationUpdateCredentialsResponse {
  bool success = 1;
  string error = 2;
}

// List federated buckets request
message FederationListBucketsRequest {}

message FederationListBucketsResponse {
  repeated FederationGetBucketStatusResponse buckets = 1;
}

// ===== DISASTER RECOVERY =====

// RecoverCollectionsRequest initiates recovery from metadata services.
message RecoverCollectionsRequest {
  // Addresses of metadata services to query (e.g., "localhost:8083")
  // If empty, uses currently registered metadata services.
  repeated string metadata_addresses = 1;

  // If true, only report what would be recovered without applying changes.
  bool dry_run = 2;
}

// RecoverCollectionsResponse contains the result of recovery operation.
message RecoverCollectionsResponse {
  bool success = 1;
  int32 collections_recovered = 2;   // New collections added
  int32 collections_skipped = 3;     // Already existed in manager
  int32 collections_failed = 4;      // Failed to recover
  string message = 5;
  repeated string recovered_names = 6;  // Names of recovered collections
  repeated string skipped_names = 7;    // Names of skipped collections
  repeated string failed_names = 8;     // Names that failed
}
